import { supabaseAdmin } from './supabaseClient';
import type { 
  Ticket, 
  CreateTicketInput, 
  UpdateTicketInput,
  TicketStatus,
  TicketPriority 
} from '../types';

if (!supabaseAdmin) {
  throw new Error('Supabase admin client is not initialized. Check SUPABASE_SERVICE_KEY.');
}

/**
 * Get all tickets with optional filters
 */
export async function getAllTickets(
  filters?: {
    status?: TicketStatus;
    priority?: TicketPriority;
    assigned_to?: string;
    customer_email?: string;
    limit?: number;
    offset?: number;
  }
): Promise<Ticket[]> {
  let query = supabaseAdmin
    .from('tickets')
    .select('*')
    .order('created_at', { ascending: false });

  if (filters?.status) {
    query = query.eq('status', filters.status);
  }

  if (filters?.priority) {
    query = query.eq('priority', filters.priority);
  }

  if (filters?.assigned_to) {
    query = query.eq('assigned_to', filters.assigned_to);
  }

  if (filters?.customer_email) {
    query = query.eq('customer_email', filters.customer_email);
  }

  if (filters?.limit) {
    query = query.limit(filters.limit);
  }

  if (filters?.offset) {
    query = query.range(filters.offset, filters.offset + (filters.limit || 10) - 1);
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to fetch tickets: ${error.message}`);
  }

  return data || [];
}

/**
 * Get a single ticket by ID
 */
export async function getTicketById(id: string): Promise<Ticket | null> {
  const { data, error } = await supabaseAdmin
    .from('tickets')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    throw new Error(`Failed to fetch ticket: ${error.message}`);
  }

  return data;
}

/**
 * Get a ticket by ticket number
 */
export async function getTicketByNumber(ticketNumber: string): Promise<Ticket | null> {
  const { data, error } = await supabaseAdmin
    .from('tickets')
    .select('*')
    .eq('ticket_number', ticketNumber)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    throw new Error(`Failed to fetch ticket: ${error.message}`);
  }

  return data;
}

/**
 * Create a new ticket
 * Ticket number is auto-generated by the database trigger
 */
export async function createTicket(input: CreateTicketInput): Promise<Ticket> {
  const { data, error } = await supabaseAdmin
    .from('tickets')
    .insert({
      subject: input.subject,
      initial_message: input.initial_message,
      customer_email: input.customer_email,
      customer_name: input.customer_name || null,
      priority: input.priority || 'medium',
      category: input.category || null,
      source: input.source || 'api',
      status: 'new',
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to create ticket: ${error.message}`);
  }

  return data;
}

/**
 * Update a ticket
 */
export async function updateTicket(
  id: string,
  input: UpdateTicketInput
): Promise<Ticket> {
  const updateData: Partial<Ticket> = {
    ...input,
    updated_at: new Date().toISOString(),
  };

  // If status is being set to resolved, set resolved_at
  if (input.status === 'resolved' && !input.resolved_at) {
    updateData.resolved_at = new Date().toISOString();
  }

  // If status is being changed from resolved, clear resolved_at
  if (input.status && input.status !== 'resolved') {
    updateData.resolved_at = null;
  }

  const { data, error } = await supabaseAdmin
    .from('tickets')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to update ticket: ${error.message}`);
  }

  return data;
}

/**
 * Update ticket status
 */
export async function updateTicketStatus(
  id: string,
  status: TicketStatus
): Promise<Ticket> {
  return updateTicket(id, { status });
}

/**
 * Assign ticket to a user
 */
export async function assignTicket(
  id: string,
  userId: string | null
): Promise<Ticket> {
  return updateTicket(id, { assigned_to: userId });
}

/**
 * Delete a ticket
 */
export async function deleteTicket(id: string): Promise<void> {
  const { error } = await supabaseAdmin
    .from('tickets')
    .delete()
    .eq('id', id);

  if (error) {
    throw new Error(`Failed to delete ticket: ${error.message}`);
  }
}

/**
 * Get ticket statistics
 */
export async function getTicketStats(): Promise<{
  total: number;
  byStatus: Record<TicketStatus, number>;
  byPriority: Record<TicketPriority, number>;
}> {
  const { data, error } = await supabaseAdmin
    .from('tickets')
    .select('status, priority');

  if (error) {
    throw new Error(`Failed to fetch ticket stats: ${error.message}`);
  }

  const stats = {
    total: data?.length || 0,
    byStatus: {} as Record<TicketStatus, number>,
    byPriority: {} as Record<TicketPriority, number>,
  };

  data?.forEach(ticket => {
    stats.byStatus[ticket.status] = (stats.byStatus[ticket.status] || 0) + 1;
    stats.byPriority[ticket.priority] = (stats.byPriority[ticket.priority] || 0) + 1;
  });

  return stats;
}

/**
 * Fix tickets that have AI responses but wrong status
 * Updates tickets with AI responses to 'ai_responded' status if they're not resolved/closed
 */
export async function fixTicketsWithAIResponses(): Promise<number> {
  // Get all tickets that have AI responses
  const { data: ticketsWithAI, error } = await supabaseAdmin
    .from('ai_responses')
    .select('ticket_id, confidence_score')
    .order('created_at', { ascending: false });

  if (error) {
    throw new Error(`Failed to fetch AI responses: ${error.message}`);
  }

  if (!ticketsWithAI || ticketsWithAI.length === 0) {
    return 0;
  }

  // Get unique ticket IDs
  const ticketIds = [...new Set(ticketsWithAI.map(ar => ar.ticket_id))];
  
  // Get those tickets
  const { data: tickets, error: ticketsError } = await supabaseAdmin
    .from('tickets')
    .select('id, status')
    .in('id', ticketIds);

  if (ticketsError) {
    throw new Error(`Failed to fetch tickets: ${ticketsError.message}`);
  }

  let fixedCount = 0;

  // Update tickets that need fixing
  for (const ticket of tickets || []) {
    // Skip if already resolved or closed
    if (ticket.status === 'resolved' || ticket.status === 'closed') {
      continue;
    }

    // Skip if already ai_responded or human_review
    if (ticket.status === 'ai_responded' || ticket.status === 'human_review') {
      continue;
    }

    // Find the most recent AI response for this ticket
    const ticketAIResponses = ticketsWithAI.filter(ar => ar.ticket_id === ticket.id);
    const mostRecent = ticketAIResponses[0];
    
    // Determine status based on confidence
    const newStatus = mostRecent.confidence_score < 0.6 ? 'human_review' : 'ai_responded';

    // Update ticket status
    try {
      await updateTicketStatus(ticket.id, newStatus);
      fixedCount++;
    } catch (error) {
      console.error(`Failed to update ticket ${ticket.id}:`, error);
    }
  }

  return fixedCount;
}
